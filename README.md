# L2_ProjetSynthese-S4
Projet de synth√®se fait durant le S4 de la L2 Info.  
Projet fait par :
- [Brice ORLIANGE](mailto:briceorl54580@gmail.com), du groupe TP4
- [Matthieu FRITSCH](mailto:mattfritsch98380@gmail.com), du groupe TP4

________________________________________________________________________________________________________________________

# ‚ö†Ô∏è Indication pour le prof ‚ÄºÔ∏èÔ∏è‚ö†Ô∏è

On a un probl√®me incompr√©hensible, on ne connait pas la cause. On le signale, car il peut √™tre **dangereux pour la RAM**.  
Pour certains jeux de point **l'ex√©cution ne se termine pas** et **l'utilisation de la RAM fait que d'augmenter**.
Les jeux en questions sont :
 - `RapidConvexHull` avec la `data2`.
 - `SlowConvexHull` avec la `data2`, la `data3` et la `data4`

> On voulait juste signal√© cette erreur "minime" pour √©viter tout pr√©judice de votre cot√©. üòÅ üòÄ

________________________________________________________________________________________________________________________

# Consigne d'ex√©cution
Voici les consignes d'ex√©cution de ce projet.  

## 1. Model
Voici le model de la commande pour ex√©cut√© le main :
```shell
make; ./convexhull algo infilename outfilename sort     
```

## 2. Arguments
Voici une explication de chaque argument √† utiliser pour lancer le projet.

### 2.1. Choix de l'algorithme `algo`
 - `s` : correspond √† **SlowConvexHull**.
   - `c` : correspond √† **ConvexHull**, on a besoin du `sort` :
   - `1` : CBTHeapSort
   - `2` : ArrayHeapSort
   - `3` : SelectionSort
 - `r` : correspond √† **RapidConvexHull**.
 - `a` : correspond √† **All**. _(execute tous les algorithmes avec les 4 fichiers data donn√©s)_

### 2.2. Fichier d'entr√©e et de sortie
Suivie de l'algorithme, utiliser entr√© les fichiers d'entr√©e et de sortie sous ce format :  
```
infilename outfilename
```

## 3. Exemple
Voici plusieurs exemples d'utilisation pour les diff√©rents algorithmes

### 3.1. SlowConvexHull
`./convexhull s infilename outfilename`

### 3.2 ConvexHull
#### 3.2.1. CBTHeapSort
`./convexhull c infilename outfilename 1`
#### 3.2.2. ArrayHeapSort
`./convexhull c infilename outfilename 2`
#### 3.2.3. SelectionSort
`./convexhull c infilename outfilename 3`

### 3.3 RapidConvexHull
`./convexhull r infilename outfilename`
### 3.4 TOUS
`./convexhull a infilename outfilename`

________________________________________________________________________________________________________________________

# RAPPORT DE PROJET
> Ce rapport est la version pour le README du projet !

## 1. Introduction
A travers ce rapport de projet de synth√®se, nous allons vous montrer par quel moyen nous avons r√©alis√© cette premi√®re partie en C.

Tout d'abord nous allons vous pr√©senter quels outils nous avons utilis√©s pour d√©velopper cette premi√®re partie, 
notre outil de communication et notre outil de partage de code.  
Puis, nous allons vous pr√©senter quelques fonctions que nous avons d√©cid√©es de r√©aliser
pour ce projet afin de nous faciliter la t√¢che pour certaines t√¢ches.
Nous allons √©galement vous pr√©senter les difficult√©s que nous avons pu rencontrer au cours de la r√©alisation du projet.  
Enfin, nous vous proposerons quelques am√©liorations qui selon nous pourrait am√©liorer la r√©alisation de ce projet.  
Vous pourrez √©galement retrouver la r√©partition des t√¢ches au sein de notre groupe et nos avis personnels 
pour chacun des points que nous allons traiter au cours du rapport. 


## 2. Outils utilis√©s
Liste des outils utilis√©s au cours du projet :
 - **CLion** : D√©veloppement de la partie en C du projet
   - **Code With Me** : Outil collaboratif de JetBrain.  
   _(M√©lange du style CLion pour le code & Google Doc pour le partage)_
 - **GitHub** : Outil pour partager notre code entre nous.
 - **Discord** : Outil pour communiquer ensemble tout au long du projet.


## 3. R√©partition des t√¢ches

### 3.1 Partie 1 : Code C
La r√©partition des t√¢ches pour faire chaque fichier _(fonctions)_ du projet :
- Brice :
   - tree.c
   - heap.c
   - sort.c
- Matthieu :
   - list.c
   - geometry.c
   - algo.c _(Brice est venu aider pour les derni√®res fonctions `convex`)_

Brice √† formater tous les fichiers pour l'uniformit√© du code. _(Brice aime bien quand c'est ranger)_

### 3.2 Partie 2 : Interface & Compl√©xit√©
La r√©partition des t√¢ches sont :
- Brice :
   - Complexit√©
   - Temps d'ex√©cution
- Matthieu :
   - Interface
   - ...  <--------------------------------------------------------------


## 4. Fonctions importantes ajout√©es
Nous avons impl√©ment√© quelques fonctions en plus qui nous ont √©t√© utiles pour le d√©veloppement du projet
Voici la pr√©sentation de ces fonctions :
 - `static void organiseTableauEnTas(ArrayHeap *AH)` dans le `heap.c`, ajout√© par Brice.  
Cette fonction appel la fonction `updateArrayHeapDownwards` dans tout les nodes se trouvant dans la couche `h - 1`.
`h` est le nombre de couches de l'arbre.


## 5. Complexit√© & temps d'ex√©cution

### 5.1. Complexit√© du ConvexHull
Calcule de la complexit√© du ConvexHull en fonction des 3 tris _(s√©lection, tas tableau et tas arbre)_.

#### 5.1.1. Complexit√© du ConvexHull sans tri
On commence par calcul√© la complexit√© de la fonction `ConvexHull`  dans le pire des cas sans prendre en compte du tri.  

La complexit√© du `ConvexHull`, est de **N**.

**Explication** :  
Sa complexit√© est de **N**, car il y a la pr√©sence _(direct ou par appel de fonction)_ de plusieurs boucles "simples" de complexit√© de **N** chacune.  
On ne trouve rien d'autre qui a une complexit√© sup√©rieur √† N dans le rest de la fonction `ConvexHull`.

**D√©tail rapide des calculs** :  
````c
C(readInstance) + 2 * (C(for) + C(while)) + C(writeSolution) + C(freeList)
= N + C(tri) + 2 * ((N - 2) + (N - (N - 4))) + 2N + 2N // (N - 2) + (N - 4) C'est un extreme ++
= N + C(tri) + 2 * N + 2N + 2N
= 7N + C(tri) // On oublie le C(tri)
= N
````

#### 5.1.2. Complexit√© des tris
Voici la complexit√© de chaque tri de mani√®re ind√©pendante.

- **trie par arbre en tas** : N  
  Car il y a deux boucles `for` qui s'ex√©cute **N fois** √† la suite qui donne **2N** en complexit√©.
- **tri par tableau en tas** : N  
  Car il y a une pr√©sence d'une boucle qui s'ex√©cute **N fois**.
- **tri par s√©lection** : N  
  Car il y a une boucle `for` √† **N - i r√©p√©tition** dans une boucle √† **N r√©p√©tition**.
  `i` est la ni√®me it√©ration du premier `for`.  
  Donc la complexit√© de la double boucle est de `N + (N - 1) + (N - 2) + (N - 3) + ...`

> Si on regarde avec un peu plus de d√©tail, on remarque que le tri le plus optimal est le **tri par tableau en tas**.  
> La version la plus gourmande est avec le tri par s√©lection.

#### 5.1.3. Complexit√© du ConvexHull avec tri
Voici la complexit√© de chaque `ConvexHull` avec leur tri inclus.

- **trie par arbre en tas** : N  
  Car `C(ConvexHull sans tri) + C(tri) = N + N = N`.
- **tri par tableau en tas** : N  
  Car `C(ConvexHull sans tri) + C(tri) = N + N = N`.
- **tri par s√©lection** : N  
  Car `C(ConvexHull sans tri) + C(tri) = N + N = N`.


### 5.2. Temps d'ex√©cution des 3 tries _(Convex)_

#### 5.2.1. CBTHeapSort
- **data1** : 0.001234 sec
- **data2** : 0.001220 sec
- **data3** : 0.001096 sec
- **data4** : 0.001142 sec

#### 5.2.2. ArrayHeapSort
- **data1** : 0.001275 sec
- **data2** : 0.000681 sec
- **data3** : 0.001346 sec
- **data4** : 0.001261 sec

#### 5.2.3. SelectionSort
- **data1** : 0.001234 sec
- **data2** : 0.000882 sec
- **data3** : 0.001200 sec
- **data4** : 0.001127 sec

#### 5.2.4. Moyenne du temps
Pour avoir une id√©e de quel des 3 tries est le plus performent dans notre programme,
on va faire la moyenne de chaque r√©sultat en fonction de chaque type de tri.  

Les moyennes sont :
- **ArrayHeapSort** : 0.001140 sec
- **CBTHeapSort** : 0.001173 sec
- **SelectionSort** : 0.001110 sec

> Le tri le plus efficace d'apr√®s notre ex√©cution de notre code est le tri par `SelectionSort` _(0.001110 sec)_.
> Cela est contradictoire avec la complexit√© calcul√©e avant.  
> L'erreur est du au probl√®me qu'on a dans notre code. 
> Pour rappel, notre code ne renvoie pas les bons r√©sultats, donc pas fiable √† 100%.

#### 5.2.5. Graphe

# !!! Mettre en place un graphe et expliqu√© pq avoir pris √ßa !!!

### 5.3. Complexit√© des 3 ConvexHull
Dans le cas du ConvexHull, on prend le tie le plus efficace des 3 tries propos√©s.  
Donc on prend le tri par `ArrayHeapSort`.

##### Complexit√©
- **RapidConvexHull** : N¬≤  
  Car il y a une boucle `for` dans une boucle `do while`. 
  Le `for` fait N fois, le `do while` fait aussi N fois dans le pire des cas, on a donc `N * N`.
- **ConvexHull** : N
- **SlowConvexHull** : N^3  
  Car il y a une boucle `for` dans une boucle `for` qui est dans une boucle `for`.  
  Chaque boucle `for` dont N boucles, qui donne `N * N * N`.
  

### 5.4. Temps d'ex√©cution des 3 ConvexHull
Dans le cas du ConvexHull, on prend le tri par `ArrayHeapSort`.

#### 5.4.1. RapidConvexHull
- **data1** : 0.000787 sec
- **data2** : _INFINI_
- **data3** : 0.000837 sec
- **data4** : 0.001237 sec

#### 5.4.2. ConvexHull
- **data1** : 0.001275 sec
- **data2** : 0.000681 sec
- **data3** : 0.001346 sec
- **data4** : 0.001261 sec

#### 5.4.3. SlowConvexHull
- **data1** : 0.001416 sec
- **data2** : _INFINI_
- **data3** : _INFINI_
- **data4** : _INFINI_

#### 5.4.4. Graphe

# !!! Mettre en place un graphe et expliqu√© pq avoir pris √ßa !!!


## 6. Difficult√©s rencontr√©es
Tout au long du d√©veloppement nous avon seu plus ou moins de mal √† r√©aliser certaines t√¢ches.
Voici une liste de quelques difficult√©s rencontr√©es avec leur explication.
_(Voir √† la fin du projet)_


## 7. Am√©liorations possibles
_(Voir √† la fin du projet)_


## 8. Conclusion
_(Voir √† la fin du projet)_

________________________________________________________________________________________________________________________

# Utilisation des commits
Chaque √©tape correspond √† comment on √©crie un commit.
> Au cours de ce projet, nous avons essay√© de respecter notre nomenclature pr√©sent√©e ci-dessous.  
> _(Notre nomenclature √† √©voluer au fil du projet, en fonction de nos besoins.)_

## 1. Importance des commits

 - üü• : Tr√®s important _(si notre vie √©tait en jeu, tr√®s rare)_
 - üüß : Important _(fonction enti√®re, code plus volumineux)_
 - üü® : Normale _(fonction partielle, code peu volumineux)_
 - üü© : Peu important _(commentaire, formatage, renommage, norme de codage, etc.)_

> Les emojis üü©, üü®, üüß, üü• sont obtenus avec la touche `windows` + `;`.

## 2. Action des commits

 - **+** : ajout
 - **~** : modification
 - **-** : suppression

## 3. Fichier/dossier cible & D√©taille

Pour savoir ce qu'on a fait apr√®s avoir indiqu√© l'importance du commit _(üü©, üü®, üüß, üü•_ et quelle action _(+, ~, -)_,
on indique dans quels fichiers √ßa √©tait appliqu√©.  
Si l'action ce porte dans l'ensemble des √©l√©ments d'un dossier, nous l'indiquerons par des `[nom_dossier]`.

On _(peut)_ ajoute entre `(...)`, les d√©tails de l'action fait sur les fichiers concerner.  
S'il y a plusieurs fichiers qui ont les m√™mes d√©taille, on met un `,` entre chaque nom de fichier (ou dossier).

**Exemple :**
```
üü© ~ fichier1, fichier2 (commentaire & format) 
```
> Le commit indique que le `fichier1` et le `fichier2` ont eu une modification dans leurs commentaires et un formatage.

## 4. Importances et actions en commun

On met un `&` entre chaque fichier/dossier cible avec son d√©taille _(s'il y a)_ et on indique √† nouveau la cible avec son d√©taille si besoin.

**Exemple :**
```
üü© + fichier1 (commentaire) & fichier2 (format)
```
> Le commit indique que le `fichier1` √† eu une modification dans ces commentaires et que le `fichier2` √† fait un formatage.

## 5. Importances et/ou actions diff√©rents

Apr√®s avoir donn√©e l'importance et l'action avec leurs cibles et d√©tailles.  
On recommence directement par indiquer l'importance puis son action pour montrer qu'on n'a pu la m√™me importance et/ou action dans les cibles qui suivent.

**Exemple :**
```
üüß + fichier1 (fonction1) üü© - fichier1 (commantaire)
```
> Le commit  indique que le `fichier1` √† ajout√© une fonction et qu'il a supprim√© un commentaire.
